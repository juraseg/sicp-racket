#lang racket
; interval abstraction
(define (make-interval a b) (cons a b))
(define (lower-bound x) (car x))
(define (upper-bound x) (cdr x))
(define (spans-zero? x)
  (if (and (negative? (lower-bound x))
           (positive? (upper-bound x)))
      #t
      #f))
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (make-center-percent c p)
  (make-center-width c (* (/ c 100) p)))
(define (center x)
  (/ (+ (lower-bound x)
        (upper-bound x))
     2))
(define (width x)
  (/ (- (upper-bound x)
        (lower-bound x))
     2))
(define (percent x)
  (/ (width x) (/ (center x) 100)))

; interval operations
(define (add-interval x y)
  (make-interval (+ (lower-bound x)
                    (lower-bound y))
                 (+ (upper-bound x)
                    (upper-bound y))))
(define (sub-interval x y)
  (make-interval (- (lower-bound x)
                    (upper-bound y))
                 (- (upper-bound x)
                    (lower-bound y))))
(define (mul-interval x y)
  (let ((a (lower-bound x))
        (b (upper-bound x))
        (c (lower-bound y))
        (d (upper-bound y)))
    (cond ((and (and (positive? a) (positive? b)) (and (positive? c) (positive? d)))
           (make-interval (* a c) (* b d)))
          ((and (and (positive? a) (positive? b)) (and (negative? c) (positive? d)))
           (make-interval (* b c) (* b d)))
          ((and (and (positive? a) (positive? b)) (and (negative? c) (negative? d)))
           (make-interval (* b c) (* a d)))
          ((and (and (negative? a) (negative? b)) (and (positive? c) (positive? d)))
           (make-interval (* a d) (* b c)))
          ((and (and (negative? a) (negative? b)) (and (negative? c) (positive? d)))
           (make-interval (* a d) (* a c)))
          ((and (and (negative? a) (negative? b)) (and (negative? c) (negative? d)))
           (make-interval (* b d) (* a c)))
          ((and (and (negative? a) (positive? b)) (and (positive? c) (positive? d)))
           (make-interval (* a d) (* b d)))
          ((and (and (negative? a) (positive? b)) (and (negative? c) (negative? d)))
           (make-interval (* b c) (* a c)))
          ((and (and (negative? a) (positive? b)) (and (negative? c) (positive? d)))
           (let ((p1 (* a c))
                 (p2 (* a d))
                 (p3 (* b c))
                 (p4 (* b d)))
             (make-interval (min p1 p2 p3 p4)
                            (max p1 p2 p3 p4)))))))
      
(define (div-interval x y)
  (cond ((spans-zero? y)
         (newline)
         (display "Error: dividing by interval which spans 0"))
        (else (mul-interval x
                            (make-interval
                             (/ 1.0 (upper-bound y))
                             (/ 1.0 (lower-bound y)))))))